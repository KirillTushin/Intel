/*
 * Tushin Kirill  
 * Stack_cpu.c
 */


#include <stdio.h>
#include <assert.h>
#include <string.h> 
#include <stdlib.h>

#define INIT_SIZE 100	//начальный размер массива

#define MULTIPLIER 2	//при недстатке памяти увечличиваем ее в MULTIPLIER раз

typedef struct Stack_tag 
{
    int* data;		//указатель на данные
    unsigned size;	//размер стека
    unsigned top;	//число элементов
} Stack_t;


Stack_t* createStack()				//создаем стек
{
    Stack_t* out = NULL;
    out = malloc(sizeof(Stack_t));
    if (out == NULL) 
    {
        assert(0);
    }
    out->size = INIT_SIZE;
    out->data = malloc(out->size * sizeof(int));
    if (out->data == NULL)
    {
        free(out);
		assert(0);
    }
    out->top = 0;
    return out;
}

void deleteStack(Stack_t **stack)		//удаляем стек
{
    free((*stack)->data);
    free(*stack);
    *stack = NULL;
}

void resize(Stack_t *stack)			//изменяем размер стека если не хватает места
{
    stack->size *= MULTIPLIER;
    stack->data = realloc(stack->data, stack->size * sizeof(int));
    if (stack->data == NULL) 
    {
        assert(0);
    }
}

void push(Stack_t *stack, int value) {		//PUSH
    if (stack->top >= stack->size) {
        resize(stack);
    }
    stack->data[stack->top] = value;
    stack->top++;
}

int pop(Stack_t *stack) {			//POP
    if (stack->top == 0) {
       assert(0);
    }
    stack->top--;
    return stack->data[stack->top];
}



int main() 
{
    char c;
    int a = 0;
	
    Stack_t *stack = createStack();
	
	FILE *mf;
	
	mf = fopen ("my.forcpu","r");
	
	while(1)
	{
		c = fgetc(mf);						//Подсчитываем количество символов
		if(c == EOF)
			break;
		a++;
	}
	a--;	
	
	int t = 0;
	
	mf = fopen ("my.forcpu","r");
	
	while(t < a)
	{
		int g = 0;
		char p = fgetc(mf);
		if(p - '0' == 1)			//PUSH
		{
			char z = fgetc(mf);
			z = fgetc(mf);
			while(1)		//код пробела =32  код перевода строки =10 EOF =-1
			{
				if(z == 32)
					break;
				if(z == 10)
					break;
				if(z == -1)
					break;
				g = g*10 + (z-'0');	//переводим из char в число
				z = fgetc(mf);
			}
			push(stack, g);
		}
		if(p - '0' == 2)			//POP
		{
			pop(stack);
			p = fgetc(mf);
		}
		if(p - '0' == 3)			//ADD
		{
			push(stack, pop(stack) + pop(stack));
			p = fgetc(mf);
		}
		if(p - '0' == 4)			//SUB
		{
			push(stack,-(pop(stack) - pop(stack)));
			p = fgetc(mf);
		}
		if(p - '0' == 5)			//MUL
		{
			push(stack, pop(stack)*pop(stack));
			p = fgetc(mf);
		}
		if(p - '0' == 6)			//DIV
		{
			push(stack, pop(stack)/pop(stack));
			p = fgetc(mf);
		}
		t++;
	}
	printf("%d ", pop(stack));
	deleteStack(&stack);		//удаляем стек
    
    return 0;
}

